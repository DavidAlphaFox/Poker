

local Class = {
    res = "Game"
}


function Class:set_pai_ex(t,path,node)
    if node == nil then
        node = self.cur_node
    end

    local child
    if type(path) == "string" then
        child = node:FindChild(path)
    else
        child = node:GetChild(path)
    end

    if child then
        UIAPI.SetPaiEx(child,t)
    end
end

function Class:init()

    self.em_msg = {
        "什么烂牌，真是红颜多薄命",
        "有种我们谁也别看牌，一直跟到底",
        "你敢下我就敢跟，别以为我会怕你",
        "做人不要太强，胆子小就别跟了",
        "别想了果断点，跟我全压了吧",
        "快点吧，我等的花都谢了",
        "别赢了就想走呀，我们决战到天亮",
        "我要走了，下次玩吧",
        "今天心情好，赢了真不好",
        "今天的运气太差了，我是认栽了",
    }

    Sound:play_music("paiju")

    game_ui = self

    --self.color_lai = {255,186,140}
    --self.color_lai_pi = {190,255,190}

    self.color_lai = 1
    self.color_lai_pi  = 2
    self.color_none = 3

    self.sit_count = 6
    self.lun_count=1
    self.showed=false

    self.btn_lai = self:find_child("RoomInfo/BtnLai")

    self.self_id = client.user_info.id
    self.user_id = client.user_info.id

    self.btn_auto = self:find_child("Panel/BtnAtuo")
    self.btn_auto_c = self:find_child("Panel/BtnAtuoC")
    self:enable(false,self.btn_auto_c)


    self.btn_dis = self:find_child("Panel/BtnDis")
    self.btn_friend = self:find_child("Panel/BtnGetFriend")
    self.btn_start = self:find_child("Panel/BtnStart")
    self.btn_quit = self:find_child("Panel/BtnQuit")

    self.btn_gengzhu = self:find_child("Panel/BtnPut")
    self:enable(false,self.btn_gengzhu)
    self.btn_jiazhu = self:find_child("Panel/Btnup")
    self:enable(false,self.btn_jiazhu)
    self.btn_kanpai = self:find_child("Panel/BtnShow")
    self:enable(false,self.btn_kanpai)
    self.btn_giveup = self:find_child("Panel/BtnGiveup")
    self:enable(false,self.btn_giveup)
    self.room_round_count=0

    self.choumaPanel=self:find_child("choumaPanel")
    self.vsPanel=self:find_child("vsPanel")

    self.cur_card_hint =  self:find_child("Cur")
    self:enable(false,self.cur_card_hint)

    self.ui_result =  self:find_child("Result")

    self.lunCount=self:find_child("RoomInfo/lunCount")
    self.totalZhu=self:find_child("RoomInfo/totalZhu")
    self.GameCount=self:find_child("RoomInfo/GameCount")
    self.totalzhuScores=0
    self:text("总投注数:"..self.totalzhuScores,self.totalZhu)

    self.chooseUpCount = self:find_child("Panel/chooseUpCount")
    self.cardTypePanel = self:find_child("Panel/cardType")
    self.up_chooseBtns={}
    for i = 1, 8 do
    	self.up_chooseBtns[i]=self:find_child("Panel/chooseUpCount/Image"..i)
    end
    self:enable(false,self.chooseUpCount)

    self.players = {}
    for i=1,6 do
        self.players[i] = {}
        self:push_child("Player"..i)

        self.players[i].cards = {}
        self.players[i].cards[1] = self:find_child("Card1")
        self.players[i].cards[2] = self:find_child("Card2")
        self.players[i].cards[3] = self:find_child("Card3")

        self.players[i].hint_node = self:find_child("Cur")

        self.players[i].name  = self:find_child("Name")
        self.players[i].pic  = self:find_child("Head")
        self.players[i].effect = self:find_child("Effect")
        self.players[i].ok = self:find_child("Ok")
        self.players[i].offline = self:find_child("Dis")
        self.players[i].speaking = self:find_child("speaking")

        self.players[i].hold_id = {}

        self.players[i].score = 0
        self.players[i].cur_score = 0

        self.players[i].em_effect = self:find_child("EmEffect")

        self.players[i].scoreTxt = self:find_child("Score")
        self.players[i].compareBtn = self:find_child("Compare")
        self:text(self.players[i].score,self.players[i].scoreTxt)

        self.players[i].room_host = self:find_child("room_host")
        self.players[i].room_zhuang = self:find_child("room_zhuang")
        self.players[i].showedMark=self:find_child("showed")

        self:enable(false,self.players[i].name)
        self:enable(false,self.players[i].pic)
        self:enable(false,self.players[i].ok)
        self:enable(false,self.players[i].offline)
        self:enable(false,self.players[i].scoreTxt)
        self:enable(false,self.players[i].compareBtn)
        self:enable(false,self.players[i].room_host)
        self:enable(false,self.players[i].room_zhuang)
        self:enable(false,self.players[i].showedMark)
        self.players[i].hasgiveup=false
        self.players[i].showed=false
        self:pop_child()
    end
    self:enable(false,self.ui_result)

    self:clear_all()
end

function Class:destroy()
    game_ui = nil
end

function Class:play_player_effect(index,effect,ex_pic,color)
    if ex_pic then
        if color then
            local node = self:effect_image(effect,ex_pic,self.players[index].effect)
            UIAPI.SetPaiEx(node,color)
        else
            self:effect_image(effect,ex_pic,self.players[index].effect)
        end
    else
        self:effect(effect,self.players[index].effect)
    end
end

function Class:is_self_turn()
    return (self.self_id == self.turn_id)
end

function Class:show_result(win_ids,datas)

	print("show_result")
    self:enable(true,self.ui_result)

    	local base = self.room_params.base_score

        local win = 0

        self:push_child("Result/Scores")
        local infoCount=0
        
        local finalScore={}
        local maxScore=0
        local bossCount=1
        for i = 1, 6 do
            self:enable_child(true,"Player"..i)
        end
        for k, v in pairs( self.infos ) do
            print(v.state)
            if v.state~="not_play" and v.state~=nil then
                infoCount=infoCount+1
                local index=self:get_playersCount_byid(k)

                self:text(v.name.."\nID:"..k,self:find_child("Player"..infoCount.."/info"))

                if v.state=="give_up" then
                    self:enable_child(true,"Player"..infoCount.."/qipai")
                else
                    self:enable_child(false,"Player"..infoCount.."/qipai")
                end

                self:image(v.head,self:find_child("Player"..infoCount.."/head"))
                if k==game_ui.host_id then
                    self:enable_child(true,"Player"..infoCount.."/head/Image")
                else
                    self:enable_child(false,"Player"..infoCount.."/head/Image")
                end

                for a,b in ipairs(datas) do
                    print(b.id)
                    if b.id==k then
                        local cards = b.cards
                        for i=1,3 do
                            self:set_card_value(self:find_child("Player"..infoCount.."/Cur/Image"..i),cards[i+1])
                        end
                        if cards[1]==10 then
                            self:text("豹子",self:find_child("Player"..infoCount.."/type"))
                        elseif cards[1]==9 then
                            self:text("同花顺",self:find_child("Player"..infoCount.."/type"))
                        elseif cards[1]==8 then
                            self:text("同花",self:find_child("Player"..infoCount.."/type"))
                        elseif cards[1]==7 then
                            self:text("顺子",self:find_child("Player"..infoCount.."/type"))
                        elseif cards[1]==6 then
                            self:text("对子",self:find_child("Player"..infoCount.."/type"))
                        elseif cards[1]==5 then
                            self:text("散牌",self:find_child("Player"..infoCount.."/type"))
                        end

                        self:text(b.gold,self:find_child("Player"..infoCount.."/Score"))   -- 单局输赢分数？？

		                self:text("喜钱:"..b.ex_gold,self:find_child("Player"..infoCount.."/xiqian"))

		                self:enable_child(false,"Player"..infoCount.."/winner")
		                self:enable_child(false,"Player"..infoCount.."/Boss")

		                finalScore[infoCount]=b.gold+b.ex_gold
		                print(finalScore[infoCount])
		                print(b.gold)
		                print(b.ex_gold)
		                if maxScore<finalScore[infoCount] then
		                    maxScore=finalScore[infoCount]
		                    bossCount=infoCount
		                end
		                if self.self_id==b.id then
		                	print(self.self_id)
		                	print(b.id)
		                    if finalScore[infoCount]>=0 then
		                        win=1
		                    else
		                        win=-1
		                    end
		                end
                    end
                end
            end
        end

        self:enable_child(true,"Player"..bossCount.."/winner")
        self:enable_child(true,"Player"..bossCount.."/Boss")

        print("infoCount"..infoCount)
        for i = tonumber(infoCount+1), 6 do
            print("Player"..i)
        	self:enable_child(false,"Player"..i)
        end

        self:pop_child()

        self:text_child("轮数:"..self.lun_count.."/8","Result/result_lun")
        self:enable_child(false,"Result/Win")
        self:enable_child(false,"Result/Lost")

        if win == 1 then
            self:enable_child(true,"Result/Win")
        elseif win == -1 then
            self:enable_child(true,"Result/Lost")
        end

        self:text_child(string.format("回合:%d/%d", "1",
                        self.room_params.round_count),
            "Result/Turn")

        if self.room_round_count >= self.room_params.round_count then
        	UI:enable_child(true,"BtnQuit",self.ui_result)
            local fun = function()
                show_history(true)
            end
            UI:button_child(fun,"BtnQuit",self.ui_result)
            UI:enable_child(false,"BtnStart",self.ui_result)
        else
            UI:enable_child(true,"BtnStart",self.ui_result)
            UI:enable_child(false,"BtnQuit",self.ui_result)
        end
end

function Class:set_lun_count()
	local countstr="轮数:"..self.lun_count.."/8"
    self:text(countstr,self.lunCount)
end

-- function Class:

function Class:turn_id(id,time,round)
    print("turn_id",id)
    -- print(round,"turnid 轮次")
    for k, v in pairs( self.infos ) do
        print( k, v.state )
    end
    if round then
    	self.lun_count=round+1
    	if self.lun_count>8 then
    		self.lun_count=self.lun_count-8
    	end
    end
    self:set_lun_count()
    self:enable(false,self.chooseUpCount)
	self:show_check(id)
    local n = self.id_order[id]
    self:enable(true,self.cur_card_hint)
    self.cur_card_hint.transform.parent = self.players[n].hint_node
    self.cur_card_hint.transform.localPosition = Vector3(0,-25,0)
    if id==self.self_id then
	    self:enable(true,self.btn_gengzhu)
	    self:enable(true,self.btn_jiazhu)
	    if not self.showed then
	    	self:enable(true,self.btn_kanpai)
	    else
	    	self:enable(false,self.btn_kanpai)
	    end
	    self:enable(true,self.btn_giveup)
	    if game_ui.base_put==5 then
	    	self:enable(false,self.btn_jiazhu)
	    end
	else
		self:enable(false,self.btn_gengzhu)
	    self:enable(false,self.btn_jiazhu)
	    self:enable(false,self.btn_kanpai)
	    self:enable(false,self.btn_giveup)
    end
    self.infos[id].state="playing"
end

function Class:show_check(id)
    print(self.lun_count)
	if id==self.self_id then
        for k, v in pairs( self.infos ) do
            print( k, v.state )
        end
		if self.lun_count==1 then
			-- print("第一轮")

		elseif self.lun_count==2 then
            -- print("第二轮")
            local mark=-1
            for i = 2, 6 do
                -- if self.players[i].id
                for k, v in pairs( self.id_order ) do
                    if v==i then
                        if self.infos[k].state ~="not_play" and self.infos[k].state~="give_up" and self.infos[k].state~=nil then
                        -- if self.infos[k].state=="playing" then
                                self:enable(true,self.players[i].compareBtn)
                                mark=0
                            break
                        end
                    end
                end
                if mark==0 then
                    break
                end
            end
		elseif self.lun_count>2 then
			-- print("大于2轮")
			for k, v in pairs( self.id_order ) do
                -- if self.infos[k].state~="not_play" and self.infos[k].state~="give_up" then
                if self.infos[k].state=="playing"then
                    if self.players[v].hasgiveup then

                    else
                        self:enable(true,self.players[v].compareBtn)
                    end
                end
			end
		else
			-- print("-1轮")
			for k, v in pairs( self.id_order ) do
				self:enable(false,self.players[v].compareBtn)
			end
		end
	else
		-- print("不是自己轮")
		for i=1,6 do
			self:enable(false,self.players[i].compareBtn)
		end
	end
end

function Class:find_next_playing_player()
    local count=-1
    for k, v in pairs( self.infos ) do
        if count==0 then
            if v.state~="not_play" and v.state~="give_up" then
                self:enable(true,self.players[self.id_order[v.id]].compareBtn)
                count=1
                break
            else

            end
        end
        if id==v.id then
            count=0
        end
    end
end

function Class:clear_all()
	print("clear_all")
    self.dis_click_cards = false
    self.click_index = nil
    self.card_lai =  nil
    self.card_lai_pi =  nil

    -- self.base_put = 1
    self.base_put = 0

    self:set_time(nil,0)

    self:enable(false,self.btn_friend)
    self:enable(false,self.btn_start)

    self:enable(false,self.cur_card_hint)

    for i=1,self.sit_count do
         local player = self.players[i]

         for _,v in ipairs(player.cards) do
             self:enable(false,v)
         end

         self:enable(false,player.ok)

         UIAPI.DeletetAllChild(player.em_effect)
         UIAPI.DeletetAllChild(player.effect)
    end
    UIAPI.DeletetAllChild(self.choumaPanel)
    self.lun_count=1
    self:set_lun_count()
    for i=1,6 do
    	self:enable(false,self.players[i].compareBtn)
    end
    UIAPI.DeletetAllChild(self.cardTypePanel)
end

function game_click_tuoguan()
    proto.room.cancel_tuoguan()
    self:enable(false,self.btn_tuo)
end

function game_click_show_result()
	print("show_result")
    game_ui:show_result()
end

function game_click_quit()
    --UI.show_watting()
    if not game_ui.started then
        if game_ui.self_id == game_ui.host_id then

            local fun_retry = function()
            	print("jiesantuichu  ")
                proto.room:quit()
            end

            local fun_quit = function()
            end

            UI.msg_box("牌局未开始\n房主解散房间钻石退还",fun_retry,fun_quit)
        else
        	print("tuichu")
            proto.room:quit()
        end
    else
        if game_ui.history then
            if game_ui.history.round >= game_ui.history.max_count then
                proto.room:quit()
                return
            end
        end

        proto.room:quit_vote_yes()
    end
end

function Class:update_voto(dt)
    --print("update_voto")
    if self.vote_node == nil then
        return
    end
    if self.vote_time == nil then
        return
    end

    self.vote_time = self.vote_time - dt

    if self.vote_time < 0 then
        self.vote_time = 0
    end
    --print(self.vote_time,dt)

    local n  = math.floor(self.vote_time)

    UI:text_child("倒计时："..tostring(n).."秒","Timer",self.vote_node)

end

function Class:quit_voto(time,ids)
    if not self.vote_node then
        self.vote_node = UI.show_temp("Vote")
    end

    local yes = #ids
    self.vote_ids = ids
    self.vote_time = time

    local voted = false
    for _,v in ipairs(ids) do
        if v == self.self_id then
            voted = true
        end
    end

    if voted then
        UI:enable_child(false,"BtnYes",self.vote_node)
        UI:enable_child(false,"BtnNo",self.vote_node)
    else
        UI:enable_child(true,"BtnYes",self.vote_node)
        UI:enable_child(true,"BtnNo",self.vote_node)
    end

    UI:enable_child(false,"BtnOk",self.vote_node)

    if game_ui.order then
        UI:text_child("同意："..tostring(yes).."/"..#game_ui.order,"NoteYes",self.vote_node)
    elseif game_ui.infos then
        UI:text_child("同意："..tostring(yes).."/"..#game_ui.infos,"NoteYes",self.vote_node)
    else
        UI:text_child("同意："..tostring(yes).."/4","NoteYes",self.vote_node)
    end

    UI:enable_child(true,"Timer",self.vote_node)

    --UI:text_child("反对："..tostring(#no),"NoteNo",game_ui.vote_node)
end

function Class:quit_voto_time(time)
    UI.msg_box(tostring(time).."秒后才能，\n再次投票退出！")
end

function Class:quit_voto_end(yes)
    if not self.vote_node then
        self.vote_node = UI.show_temp("Vote")
    end

    if yes then
        local fun = function()
            UI.close_watting()
            UI.close_all()
            UI.create("main_ui")
            self.vote_node = nil
        end
        UI:button_child(fun,"BtnOk",self.vote_node)

        UI:text_child("全部同意 游戏结束","NoteYes",self.vote_node)
    else
        local fun = function()
            self.vote_node = nil
        end
        UI:button_child(fun,"BtnOk",self.vote_node)
        UI:text_child("有人反对 游戏继续","NoteYes",self.vote_node)
    end

    UI:enable_child(true,"BtnOk",self.vote_node)

    UI:enable_child(false,"BtnYes",self.vote_node)
    UI:enable_child(false,"BtnNo",self.vote_node)

    UI:enable_child(false,"Timer",self.vote_node)
    --UI:enable_child(false,"NoteYes",self.vote_node)
    --UI:enable_child(false,"NoteNo",self.vote_node)

    UI:enable_child(true,"BtnOk",self.vote_node)
end

function game_click_vote_yes()
    proto.room:quit_vote_yes()
    UI:enable_child(false,"BtnYes",game_ui.vote_node)
    UI:enable_child(false,"BtnNo",game_ui.vote_node)
end

function game_click_vote_no()
    proto.room:quit_vote_no()
    UI:enable_child(false,"BtnYes",game_ui.vote_node)
    UI:enable_child(false,"BtnNo",game_ui.vote_node)
end

function game_click_dis()
    UI.show_watting()
    proto.room:quit()
end

function game_click_friend()
    local type
    local pay
    if game_ui.room_params.type == 0 then
        type = "炸金花"
    else
        type = "炸金花"
    end

    if game_ui.room_params.player_count == 0 then
        pay = "房主付费"
    else
        pay = "每人付费"
    end
    local str = string.format("share,炸金花,打开游戏，输入房间号(%d)，大战(%d)局，%d人玩法,%s",
        client.room_id,game_ui.room_params.round_count,game_ui.room_params.ex_param2,game_url)
    print(str)
    GameAPI.CallFun( str )
end

function game_click_start()

    if game_ui.temp_result then
        UI.destroy_temp(game_ui.temp_result)
        game_ui.temp_result = nil
    end

    if game_ui.history then
        if game_ui.history.round >= game_ui.room_params.round_count then
            show_history(true)
            return
        end
    end

    proto.room:start()
    click_auto_cancel()
end

-- message
function Class:tuoguan()
    self:enable(true,self.btn_tuo)
end

function Class:show_txt_msg_ack(id,msg)
	local index=self:get_playersCount_byid(id)-1
    -- local index = self.id_order[id] - 1
    local temp = UI.show_temp(string.format("Chat_%d",index))
    self:text_child(msg,"Chat/Text",temp)
end

function Class:set_em_txt(node)
    for i,v in ipairs(self.em_msg) do
        self:text_child(v,i-1,node)
    end
end

function Class:show_emotion_ack(id,em)
    print(em)
    if em >= 50 then
        em = em - 50 + 1
    if self.infos[id].sex == 1 then
        Sound:play_sound(string.format("boy_fix_msg_%d",em))
    else
        Sound:play_sound(string.format("girl_fix_msg_%d",em))
    end
        self:show_txt_msg_ack(id,self.em_msg[em])
    else
        local index = self.id_order[id]
        UIAPI.DeletetAllChild(self.players[index].em_effect)
        local node = UIAPI.CreateChild(self.players[index].em_effect,"effect/emotion",false)
        UIAPI.SetEmImage(node:FindChild("Image"),em)
    end
end

--进入响应

            --     id: x.id,
            --     name: x.name,
            --     sex: x.sex,
            --     head: x.head,
            --     ip: x.ip,
            --     started: x.started,
            --     offline: x.off_line,
            --     pos: x.pos,
            --     gold: x.gold,
function Class:enter_ack(host_id,rounds,round_host,infos,room_params)

    print("enter_ack")

    self:enable(true,self.btn_friend)
    self:enable(true,self.btn_start)

    self.host_id = host_id
    self.infos = infos
    self.room_params = room_params
    print(room_params.ex_param2.."房间人数上限")

	print(rounds.."当前局数")
    self.room_round_count=rounds
	self:dis_game_count(self.room_round_count)

    self.id_order = {}


    for i,v in ipairs(infos) do
        print(v.id)
        print(v.pos)
        if v.id == client.user_info.id then
            self.self_pos = v.pos
        end
    end

    self.id_order = {}
    for i,v in ipairs(infos) do
        self.id_order[v.id] = 1 + (self.sit_count + v.pos - self.self_pos) % self.sit_count
    end

    self.infos = {}
    for i,v in ipairs(infos) do
        local index = self.id_order[v.id]
        self.infos[v.id] = v

        self:enable(true,self.players[index].name)
        self:enable(true,self.players[index].pic)
        self:text(v.name,self.players[index].name)
        self:image(v.head,self.players[index].pic)

        self:enable(v.offline,self.players[index].offline)
        self:enable(true,self.players[index].scoreTxt)
        self:enable(false,self.players[index].compareBtn)
        if host_id==v.id then
        	self:enable(true,self.players[index].room_host)
        end
        print(round_host)
        -- print(v.id)
        if round_host==v.id then
        	-- local ind=self:get_playersCount_byid(v.id)
        	self:enable(true,self.players[index].room_zhuang)
        end

        self:enable(v.started,self.players[index].ok)
        print(v.gold)
        self.players[index].score=v.gold
        self:text(self.players[i].score,self.players[i].scoreTxt)
        self.players[index].id = v.id
        -- self.players[n].hasgiveup
    end
        if round_host==0 then
            self:enable(true,self.players[self.id_order[self.host_id]].room_zhuang)
        end

    self:text_child("房间"..tostring(client.room_id),"RoomInfo/ID")
    for i = 1, 6 do
    	self:enable(false,self.players[i].compareBtn)
    end
end

function Class:start_voice(id)
    if self.voice_effect then
        self:destroy_temp(self.voice_effect)
        self.voice_effect = nil
    end
    local index = self.id_order[id]
    -- self.voice_effect = self:effect("Speek",self.players[index].effect)
    self.voice_effect = self:effect("Speek",self.players[index].speaking)
end

-- infos.state
-- not_play,
-- playing,
-- give_up,
--新玩家进入
function Class:enter_player(info)

            -- id: player.id,
            -- name: player.name,
            -- sex: player.sex,
            -- head: player.head,
            -- ip: player.ip,
            -- started: player.started,
            -- offline: player.off_line,
            -- pos: player.pos,
            -- gold: player.gold
    print("enter_player")
    info.state="not_play"

    n = 1 + (self.sit_count + info.pos - self.self_pos) % self.sit_count

    self:enable(true,self.players[n].name)
    self:enable(true,self.players[n].pic)
    self:text(info.name,self.players[n].name)
    self:image(info.head,self.players[n].pic)

    self:enable(info.started,self.players[n].ok)

    self:enable(info.offline,self.players[n].offline)

    self:enable(true,self.players[n].scoreTxt)
    self:enable(true,self.players[n].compareBtn)
    self:enable(false,self.players[n].room_host)
    self:enable(false,self.players[n].room_zhuang)
    self:enable(false,self.players[n].compareBtn)

    self.players[n].score=info.gold
    self:text(self.players[n].score,self.players[n].scoreTxt)

    self.players[n].id = info.id
    self.infos[info.id] = info
    self.id_order[info.id] = n
    for k, v in pairs( self.infos[info.id] ) do
        print( k, v )
    end
end

function Class:quit_player(id)
    if self.infos[id] then
        local n = self.id_order[id]
        self:enable(false,self.players[n].name)
        self:enable(false,self.players[n].pic)
        self:enable(false,self.players[n].ok)
        self:enable(false,self.players[n].offline)
        self:enable(false,self.players[n].scoreTxt)
    	self:enable(false,self.players[n].compareBtn)
    	self:enable(false,self.players[n].room_host)
    	self:enable(false,self.players[n].room_zhuang)

        self.infos[id] = nil
        self.id_order[id] = nil
    end
end

function Class:dis_game_count(count)
    if not count then
        count = 1
    end
    -- self:text_child(string.format("%d/%d局",count,self.room_params.round_count),"RoomInfo/GameCount")
    self:text(count.."/"..self.room_params.round_count,self.GameCount)
end

function Class:game_start(order,show_start)

    self:clear_all()

    self.order = order
	self.showed=false
	self.lun_count=1
	self:set_lun_count()
    if show_start then
        self:effect("Start")
    end
    self.room_round_count=self.room_round_count+1
    self:dis_game_count(self.room_round_count)

    self.started = true

    self:enable(false,self.btn_dis)
    --self:enable(false,self.btn_quit)
    self:enable(false,self.btn_friend)
    self:enable(false,self.btn_start)

    self:enable(true,self.btn_gengzhu)
    self:enable(true,self.btn_jiazhu)
    self:enable(true,self.btn_kanpai)
    self:enable(true,self.btn_giveup)

    for n =1,self.sit_count do
        self:enable(false,self.players[n].ok)
        self:enable(false,self.players[n].cards[1])
        self:enable(false,self.players[n].cards[2])
        self:enable(false,self.players[n].cards[3])
    end

	self.totalzhuScores=0

    for k, v in pairs( self.infos ) do
        v.state="not_play"
    end
    for i,v in ipairs(order) do
        local n = self.id_order[v]

        self.infos[v].base_x = 1

        self:enable(false,self.players[n].ok)

        self:enable(true,self.players[n].cards[1])
        self:enable(true,self.players[n].cards[2])
        self:enable(true,self.players[n].cards[3])

        self:set_card_value(self.players[n].cards[1],0)
        self:set_card_value(self.players[n].cards[2],0)
        self:set_card_value(self.players[n].cards[3],0)
        self.players[n].score=self.players[n].score-1
        self:text(self.players[n].score,self.players[n].scoreTxt)
        self.totalzhuScores=self.totalzhuScores+1
        game_ui:Put_chouma(n,1)
        -- self.players[n].cur_score=-1
        self.players[n].hasgiveup=false
        self.infos[v].state="playing"
    end
    self:text("总投注数:"..self.totalzhuScores,self.totalZhu)

    print("start...\n")
end

function Class:set_card_value(t,value)

	-- print("set_card_value"..value)
    if value == 0 then
        self:image("纸牌_55",t)
    elseif value == -1 then
    	self:image("纸牌_56",t)
    elseif value==-2 then
    	self:image("纸牌_57",t)
    else
        local hua = (value - 1) % 4
        local pai = 1 + ((value - hua - 1) / 4)
        if pai == 13 then
            pai = 0
        end

        local n = hua * 13 + pai + 1

        if n < 10 then
            self:image("纸牌_0"..n,t)
        else
            self:image("纸牌_"..n,t)
        end
        --print(value,n,hua,pai)
    end
end

-- max3 gameplay
-- cmd for buttons
function cmd_show()
    print("cmd_show")
	game_ui:enable(false,game_ui.chooseUpCount)
    proto.room:put_cmd("show_card", {})
    game_ui.showed = true
	game_ui:enable(false,game_ui.btn_kanpai)
end

function cmd_put()
	game_ui:enable(false,game_ui.chooseUpCount)
	-- print(game_ui.base_put)
	print(game_ui.base_put)
    proto.room:put_cmd("put_gold", {game_ui.base_put})
end

function cmd_giveup()
	game_ui:enable(false,game_ui.chooseUpCount)
    proto.room:put_cmd("give_up", {}) --
    UIAPI.DeletetAllChild(game_ui.cardTypePanel)
end

function click_up_put(count)
	-- print(count)
    print("click_up_put")
	local ch_count=0
	if game_ui.showed then
		ch_count=count/2
	else
		ch_count=count
	end
    print(ch_count)
    print(game_ui.showed)
	-- game_ui.base_put = tonumber(ch_count)
    proto.room:put_cmd("put_gold", {ch_count})
	game_ui:enable(false,game_ui.chooseUpCount)

end
-- 1 2 3 4 5 6 8 10
function cmd_put_up()
	game_ui:enable(true,game_ui.chooseUpCount)
	-- self.base_put
	-- self.showed
	if not game_ui.showed then
		for i = 1, 5 do
			if game_ui.base_put<i then
				game_ui:enable(true,game_ui.up_chooseBtns[i])
			else
				game_ui:enable(false,game_ui.up_chooseBtns[i])
			end
		end
		for i = 6, 8 do
			game_ui:enable(false,game_ui.up_chooseBtns[i])
		end
	else
		for i = 1, 8 do
			game_ui:enable(false,game_ui.up_chooseBtns[i])
		end
		if game_ui.base_put==0 then
			game_ui:enable(true,game_ui.up_chooseBtns[2])
			game_ui:enable(true,game_ui.up_chooseBtns[4])
			game_ui:enable(true,game_ui.up_chooseBtns[6])
			game_ui:enable(true,game_ui.up_chooseBtns[7])
			game_ui:enable(true,game_ui.up_chooseBtns[8])
		elseif game_ui.base_put==1 then
			game_ui:enable(true,game_ui.up_chooseBtns[4])
			game_ui:enable(true,game_ui.up_chooseBtns[6])
			game_ui:enable(true,game_ui.up_chooseBtns[7])
			game_ui:enable(true,game_ui.up_chooseBtns[8])
		elseif game_ui.base_put==2 then
			game_ui:enable(true,game_ui.up_chooseBtns[6])
			game_ui:enable(true,game_ui.up_chooseBtns[7])
			game_ui:enable(true,game_ui.up_chooseBtns[8])
		elseif game_ui.base_put==3 then
			game_ui:enable(true,game_ui.up_chooseBtns[7])
			game_ui:enable(true,game_ui.up_chooseBtns[8])
		elseif game_ui.base_put==4 then
			game_ui:enable(true,game_ui.up_chooseBtns[8])
		elseif game_ui.base_put==5 then

		else
		end
	end

end

function cmd_check_card(count)
    print(count)
    -- if game_ui.showed then
    --     print("看牌")
        proto.room:put_cmd("check", {game_ui.players[tonumber(count)].id})
    -- else
    --     print("没看")
        proto.room:put_cmd("check", {game_ui.players[tonumber(count)].id})
    -- end
end

-- return
        -- infos
		-- public int id
		-- public int gold
		-- public PlayState state
		-- public bool showed
		-- public byte[] put_count
		-- round
		-- base_gold
--round,state.base_count,info,cards
function Class:play_info(round, base_gold,infos,cards)

	print("play_info")
    self:enable(false,self.btn_dis)
    self:enable(false,self.btn_friend)
    self:enable(false,self.btn_start)

    self.started=true

	self:enable(true,self.btn_gengzhu)
    self:enable(true,self.btn_jiazhu)
    self:enable(true,self.btn_kanpai)
    self:enable(true,self.btn_giveup)

    for n =1,self.sit_count do
        self:enable(false,self.players[n].ok)
        self:enable(false,self.players[n].cards[1])
        self:enable(false,self.players[n].cards[2])
        self:enable(false,self.players[n].cards[3])
    end

    print(#infos)
    for i,v in ipairs(infos) do
    	print(i)
    	print(v.id)
    	print(v.gold)
    	print(v.state)
    	print(v.showed)

    	local index=self:get_playersCount_byid(v.id)
    	self.players[index].score=v.gold
    	local n_score=v.gold
    	local t=game_ui.players[index].scoreTxt
    	self:text(n_score,t)
        self.infos[v.id].state=v.state
        if v.state=="give_up" then
            print("这人弃牌了")
            print(index)
            game_ui.players[index].hasgiveup=true
            self:set_card_value(self.players[index].cards[1],-2)
            self:set_card_value(self.players[index].cards[2],-2)
            self:set_card_value(self.players[index].cards[3],-2)
        else
            game_ui.players[index].hasgiveup=false
        end

		for a, b in pairs( v.put_count ) do
			self.totalzhuScores=self.totalzhuScores+b
			game_ui:Put_chouma(index,b)
			print("出gold",b)
			game_ui.players[index].score=game_ui.players[index].score-b
			-- game_ui.players[index].cur_score=game_ui.players[index].cur_score-b
		end
		self:text(game_ui.players[index].score,game_ui.players[index].scoreTxt)

        self.lun_count= round+1
        if self.lun_count>8 then
        	self.lun_count=self.lun_count-8
        end
        self:set_lun_count()

        local id = v.id
        -- local n = self.id_order[id]
        local n=self:get_playersCount_byid(v.id)
        self.infos[id].showed =v.showed
        if v.showed then
            self.infos[id].base_x = 2
            self:enable(true,self.players[self.id_order[id]].showedMark)
        else
            self.infos[id].base_x = 1
            self:enable(false,self.players[self.id_order[id]].showedMark)
        end

        if id==self.self_id then
         	self.infos[id].base_put=v.base_gold
        	self.showed=v.showed
        end

        for i=1,3 do
            self:enable(true,self.players[n].cards[i])
        end

        if (id == self.user_id) and (v.showed) then

        	for k, v in pairs( cards ) do
        		print( k, v )
        	end
        	print(#cards)
            local cardtype = GameAPI.Create2Dimage("cardType_"..cards[1])
            cardtype.transform.parent=game_ui.cardTypePanel.transform
            cardtype.transform.localPosition=Vector3(0,0,0)
            cardtype.transform.localScale = Vector3(1,1,1)
            for i=1,3 do
                self:set_card_value(self.players[n].cards[i],cards[i+1])
            end
        else
            if game_ui.players[index].hasgiveup~=true then
                for i=1,3 do
                    self:set_card_value(self.players[n].cards[i],0)
                end
            end
        end
    end
    print(self.totalzhuScores)
    self:text("总投注数:"..self.totalzhuScores,self.totalZhu)
end

function Class:get_playersCount_byid(id)
	for x = 1, 6 do
    		if self.players[x].id==id then
    			return x
    		end
    end
end

function Class:show_card_ack(id)
    print("player " .. id .. " show cards")
    self.infos[id].base_x = 2
    game_ui:play_sound(id,"kanpai",1)
    self.players[self.id_order[id]].showed=true
    self:enable(true,self.players[self.id_order[id]].showedMark)
end

function Class:Put_chouma(n,str)
	-- GameAPI.DoMove(self.players[index].cur[n],0.2,pos)
	local chouma = GameAPI.Create2Dimage("chouma_"..str)
	chouma.transform.parent=game_ui.choumaPanel.transform
	local x = math.random()*400-400/2
	local y = math.random()*200-200/2
		 chouma.transform.localPosition=Vector3(0,0,0)
	-- chouma.transform.localPosition = self.players[n].scoreTxt.transform.localToWorldMatrix
	chouma.transform.localScale = Vector3(0.8,0.8,1)
	GameAPI.DoMove(chouma,0.2,Vector3(x/100,y/100,100))
end

function Class:show_card_value(cards)
	print("show_card_value")
    print(#cards)
    for i=1,3 do
        self:set_card_value(self.players[1].cards[i],cards[i+1])
    end
    -- cardType
    -- self.players[1]:find_child("Panel/BtnPut")
	local cardtype = GameAPI.Create2Dimage("cardType_"..cards[1])
	cardtype.transform.parent=game_ui.cardTypePanel.transform
	cardtype.transform.localPosition=Vector3(0,0,0)
	cardtype.transform.localScale = Vector3(1,1,1)
end

function Class:put_gold(id,gold)
    print("player " .. id .. " put " .. gold.."     "..self.infos[id].base_x)
    -- if self.infos[id].base_x==1 and gold==0 then
    -- 	self.base_put=1
    -- elseif self.infos[id].base_x==2 and gold==0 then
    -- 	self.base_put=0
    -- end
    -- if gold > tonumber(self.base_put) then
    --     self.base_put = gold
    --     game_ui:play_sound(id,"jiazhu",1)
    -- else
    -- 	game_ui:play_sound(id,"genzhu",1)
    -- end

    local putgold_number=0
    if gold==0 then
    	if self.infos[id].base_x==1 then
    		putgold_number=1
    		self.base_put=1
    		game_ui:play_sound(id,"genzhu",1)
    	elseif self.infos[id].base_x==2 then
    		putgold_number=1
			self.base_put=0
			game_ui:play_sound(id,"genzhu",1)
    	end
    else
    	if gold > tonumber(self.base_put) then
        	self.base_put = gold
        	putgold_number=gold*self.infos[id].base_x
        	game_ui:play_sound(id,"jiazhu",1)
    	else
    		putgold_number=gold*self.infos[id].base_x
    		game_ui:play_sound(id,"genzhu",1)
    	end
    end

    local n=self:get_playersCount_byid(id)
    game_ui:Put_chouma(n,tostring(putgold_number))
    self.players[self.id_order[id]].score=self.players[self.id_order[id]].score-putgold_number
    self.players[self.id_order[id]].cur_score=self.players[self.id_order[id]].cur_score-putgold_number
    local score=self.players[self.id_order[id]].score
    local scoretxt=self.players[self.id_order[id]].scoreTxt
    self:text(score,scoretxt)
    self.totalzhuScores=self.totalzhuScores+putgold_number
    self:text("总投注数:"..self.totalzhuScores,self.totalZhu)
end

function Class:giveup_ack(id)
    print("player " .. id .. " giveup")
    game_ui:play_sound(id,"fangqi",1)
    self:set_card_value(self.players[self.id_order[id]].cards[1],-2)
    self:set_card_value(self.players[self.id_order[id]].cards[2],-2)
    self:set_card_value(self.players[self.id_order[id]].cards[3],-2)
    self:enable(false,self.players[self.id_order[id]].compareBtn)
    self.players[self.id_order[id]].hasgiveup=true
    self.infos[id].state="give_up"
end

function Class:check_result(id,id2,value)
    print( "check:".. id .. " " .. id2 .. " win:" .. tostring(value))
    game_ui:play_sound(id,"bipai",1)
    local vsicon= GameAPI.Create2Dimage("VSeffect")
    vsicon.transform.parent=game_ui.vsPanel.transform
    vsicon.transform.localPosition = Vector3(0,0,0)
	vsicon.transform.localScale = Vector3(1,1,1)

	local name_1=UI:find_child("id_1/name",vsicon.transform)
	local head_1=UI:find_child("id_1/head",vsicon.transform)
	local name_2=UI:find_child("id_2/name",vsicon.transform)
	local head_2=UI:find_child("id_2/head",vsicon.transform)

	self:text(self.infos[id].name,name_1)
	self:image(self.infos[id].head,head_1)
	self:text(self.infos[id2].name,name_2)
	self:image(self.infos[id2].head,head_2)

    -- self.players[self.id_order[id]].cur_score=self.players[self.id_order[id]].cur_score-self.base_put*self.infos[id].base_x
    Sound:play_sound("vsEffect")
	self:delay(3,function()
        if value then
	    	self:set_card_value(self.players[self.id_order[id2]].cards[1],-1)
	    	self:set_card_value(self.players[self.id_order[id2]].cards[2],-1)
	    	self:set_card_value(self.players[self.id_order[id2]].cards[3],-1)
	    	self:enable(false,self.players[self.id_order[id2]].compareBtn)
            self.infos[id2].state="check_failed"
	    else
	    	self:set_card_value(self.players[self.id_order[id]].cards[1],-1)
	    	self:set_card_value(self.players[self.id_order[id]].cards[2],-1)
	    	self:set_card_value(self.players[self.id_order[id]].cards[3],-1)
	    	self:enable(false,self.players[self.id_order[id]].compareBtn)
            self.infos[id].state="check_failed"
	    end
    end)
end

function Class:win_id(ids,datas)
    for k, v in pairs( ids ) do
        print( k, v )
    end
    -- print( "win:" .. ids)

    for i,v in ipairs(datas) do
        local n = self.id_order[v.id]
        local cards = v.cards

        local giveup=v.giveup
        if giveup then
        	for i=1,3 do
            	self:set_card_value(self.players[n].cards[i],-2)
        	end
        else
        	for i=1,3 do
            	self:set_card_value(self.players[n].cards[i],cards[i+1])
        	end
        end
        for a, b in pairs( ids ) do
            if b == v.id then
                self.players[self.id_order[v.id]].score=self.players[self.id_order[v.id]].score+v.gold
            end
        end
        self.players[self.id_order[v.id]].score=self.players[self.id_order[v.id]].score+v.ex_gold
        self:text(self.players[self.id_order[v.id]].score,self.players[self.id_order[v.id]].scoreTxt)
    end

    self.totalzhuScores=0
    self:text("总投注数:"..self.totalzhuScores,self.totalZhu)

	self:enable(false,self.btn_gengzhu)
	self:enable(false,self.btn_jiazhu)
	self:enable(false,self.btn_kanpai)
	self:enable(false,self.btn_giveup)
	for i = 1, 6 do
		self:enable(false,self.players[i].compareBtn)
		self:enable(false,self.players[i].room_zhuang)
        self:enable(false,self.players[i].showedMark)
	end
    self:enable(true,self.players[self.id_order[ids[1]]].room_zhuang)
	self:delay(3,function()
		self:show_result(ids,datas)
		self:enable(true,self.btn_start)
	end)
end

function Class:end_games(his)
	self.zongjiesuan_his=his
    -- client:room_show_history(his,quit)
end

-- end max3 gameplay

function Class:set_time(index)
    if self.time_index and self.turn[self.time_index] then
        self.turn[self.time_index]:SetActive(false)
    end

    self.time_index = index
    if index then
        self.turn[index]:SetActive(true)
    end

    if index == nil and self.num_1 then
        self:enable(false,self.num_1)
        self:enable(false,self.num_2)
    end
end

function Class:set_time_dis()
    local n = self.n

    if n < 0 then
        n = 0
    end

    local n1  = math.floor(n/10)
    local n2  = n % 10

    if self.num_1 then
        self:number_image(n1,self.num_1)
        self:number_image(n2,self.num_2)
    end
end

function Class:has_four(cards,card)
    local n = 0
    for _,v in pairs(cards) do
        if v == card then
            n = n + 1
        end
    end

    return n
end

function Class:play_sound(id,sound,rnd)
    local head
    if self.infos[id].sex == 1 then
        head = "boy_"
    else
        head = "girl_"
    end
    sound = head..sound

    if rnd then
        sound = sound .. string.format("_%d",math.random(rnd)-1)
    end
    -- print(self.infos[id].sex,sound)
    Sound:play_sound(sound)
end

function Class:add_score(id,score)
    local index = self.id_order[id]
    self.players[index].score = self.players[index].score + score
end

function Class:set_score(id,score)
    local index = self.id_order[id]
    self.players[index].score = score
end

function Class:set_his_score(his)
    if his.data then
        for _,v in pairs(his.data) do
            self:set_score(v.id,v.score)-- body...
        end
    end
end

-- function Class:show_score_anim()
-- 	for k, v in pairs( self.cur_add_score ) do
-- 		if v~=0 then
-- 			local ani=UI.show_temp("ScoreAnim_"..k)
-- 			if v>0 then
-- 				self:text_child("+"..tostring(v),"ScoreAnim_"..k,ani)
-- 			else
-- 				self:text_child(tostring(v),"ScoreAnim_"..k,ani)
-- 			end
-- 		end
-- 	end
-- 	self.cur_add_score={}
-- end

function Class:room_score(id,otherId,score)
    if otherId == 0 then
        local s = 0
        for k,_ in pairs(self.id_order) do
            self:add_score(k,-score)
            s = s + score
        end
        self:add_score(id,s)
    else
        self:add_score(id,score)
        self:add_score(otherId,-score)
    end
end

function Class:update(dt)

    self:update_voto(self.dt)

    self:update_replay()
end

function Class:room_player_ready_ack(id)
    local n = self.id_order[id]
    self:enable(true,self.players[n].ok)
end

function click_auto()
    game_ui:enable(false,game_ui.btn_auto)
    game_ui:enable(true,game_ui.btn_auto_c)
    game_ui.auto = true
end

function click_auto_cancel()
    game_ui:enable(true,game_ui.btn_auto)
    game_ui:enable(false,game_ui.btn_auto_c)
    game_ui.auto = false
end

-- replay
function replay_play()
    print(game_ui.replay_doing)

    if game_ui.replay_doing then
        return
    end

    Time.timeScale = 1
    if not game_ui.replay_cur_data then
        game_ui:set_replay_data()
    else
        game_ui.replay_doing = true
    end

    game_ui:replay_enable_btn()
end

function replay_pause()
    if not game_ui.replay_doing then
        return
    end
    game_ui.replay_doing = false
    Time.timeScale = 0
    game_ui:replay_enable_btn()
end

function replay_step(step)

    if game_ui.replay_cur_data then
        if game_ui.replay_doing then
            replay_pause()
        end
        game_ui:clear_delay()
        game_ui:fast_step(step)
    end
end

function replay_next()
    game_ui:clear_delay()

    if game_ui.replay_cur >= game_ui.replay_game_count then
        return
    end
    game_ui.replay_cur = game_ui.replay_cur + 1
    game_ui.replay_cur_data =  nil

    game_ui.replay_doing = false
    replay_play()
end

function replay_prev()
    game_ui:clear_delay()

    if game_ui.replay_cur <= 1 then
        return
    end
    game_ui.replay_cur = game_ui.replay_cur - 1
    game_ui.replay_cur_data =  nil

    game_ui.replay_doing = false
    replay_play()
end

function quit_replay()
    UI.close_watting()
    UI.close_all()
    UI.create("main_ui")
end

function Class:init_replay(game_id,data)

    self.show_pai = true

    self:enter_ack(0,data.players,data.room_params)

    self.replay_game_id = game_id
    self.replay_order = data.order
    self.replay_game_count = data.game_count
    self.replay_cur  = 1

    self.replay_data = {}

    self:enable_child(false,"Panel")
    self.replay_node = UI.show_temp("Replay")

    game_ui:replay_enable_btn()
end

function Class:replay_enable_btn()

    print( self.replay_cur,self.replay_game_count)
    if self.replay_cur >= self.replay_game_count then
        self:image_color_child({128,128,128},"Next",self.replay_node)
    else
        self:image_color_child({255,255,255},"Next",self.replay_node)
    end

    if self.replay_cur <= 1 then
        self:image_color_child({128,128,128},"Prev",self.replay_node)
    else
        self:image_color_child({255,255,255},"Prev",self.replay_node)
    end

    if self.replay_doing then
        self:image_color_child({128,128,128},"Play",self.replay_node)
        self:image_color_child({255,255,255},"Pause",self.replay_node)
    else
        self:image_color_child({128,128,128},"Pause",self.replay_node)
        self:image_color_child({255,255,255},"Play",self.replay_node)
    end
end

function Class:set_replay_data(id,data)
    if data then
        local steps = data.steps
        local len = #steps

        local new_steps = {}
        for i=1,len do
            new_steps[i] = steps[len-i+1]
        end

        data.steps = new_steps
        game_ui.replay_data[id] = data
    end
    game_ui.replay_cur_data = game_ui.replay_data[game_ui.replay_cur]

    if game_ui.replay_cur_data then

        self:clear_delay()

        local count = #game_ui.replay_cur_data.steps / 2
        self:slider_child(0,"Step",self.replay_node)
        self:slider_count_child(count,"Step",self.replay_node)

        game_ui.replay_doing = true
        game_ui.replay_cur_step = 1
        game_ui.replay_wait_time = 1

        local cards = {}

        for i,v in ipairs(game_ui.replay_cur_data.cards) do
            local id = self.replay_order[i]

            local data_new = {}

            for k,m in pairs( v.datas) do
                data_new[k] = m
            end

            cards[i] = {
                id = id,
                cur = data_new,
                hold = {},
                old = {},
                cheng = 0,
            }
        end

        local round_host_id = game_ui:get_replay_round_host_id()

        game_ui:re_enter(0,round_host_id,game_ui.replay_order,
            cards,game_ui.replay_cur_data.card_count,
            game_ui.replay_cur_data.pi_card,{round=game_ui.replay_cur})

        game_ui:replay_enable_btn()
    else
        UI.show_watting()
        proto.room:get_replay_data(game_ui.replay_game_id,game_ui.replay_cur)
    end
end

function Class:get_replay_round_host_id()
    local ind = self.replay_cur_data.steps[1+1]
    ind = ind % 16
    return self.replay_order[ind]
end

function Class:update_replay()
    if self.replay_doing then
        if self.replay_wait_time then
            self.replay_wait_time = self.replay_wait_time - self.dt
        else
            self.replay_wait_time = 0
        end

        if self.replay_wait_time <= 0
            and self.replay_cur_step  < #self.replay_cur_data.steps then

            local ind = self.replay_cur_data.steps[self.replay_cur_step+1]
            local cmd = math.floor(ind / 16)
            ind = ind % 16
            local card = self.replay_cur_data.steps[self.replay_cur_step]

            local id = self.replay_order[ind]

            print(ind,cmd,id,card)

            if cmd == 0 then
                local turn_flag = 0

                if self.replay_cur_step > 1 then
                    local last_ind = self.replay_cur_data.steps[self.replay_cur_step+1-2]
                    local last_cmd = math.floor(last_ind / 16)
                    last_ind = last_ind % 16
                    local last_card = self.replay_cur_data.steps[self.replay_cur_step-2]
                    if last_cmd == 3 then
                        turn_flag = 1
                    elseif (last_cmd == 1) and (last_card == self.card_lai) then
                        turn_flag = 1
                    end
                end
                self:turn_player(id,turn_flag,card,{})
                self.replay_wait_time = 1
            elseif cmd == 1  then
                self:put_card(id,card)
                self.replay_wait_time = 1
            elseif cmd == 2  then
                self:room_peng(id,card)
                self:turn_player(id,0,0,{})
                self.replay_wait_time = 1
            elseif cmd == 3  then
                local count  = 0
                for k,v in pairs(self.cards[id].cur) do
                    if v == card then
                        count = count + 1
                    end
                end
                self:room_gang(id,card,count)
                self:turn_player(id,0,0,{})
                self.replay_wait_time = 1
            elseif cmd == 4  then
                local win_cards = {}
                for i,p_id in ipairs(self.order) do
                    local cards = {}
                    for i,v in ipairs(self.cards[p_id].cur) do
                        cards[i] = v
                    end

                    if self.cards[p_id].cur[0] then
                        table.insert(cards,1,self.cards[p_id].cur[0])
                    end

                    win_cards[i] = {datas=cards}
                end
                self:room_hu({id},win_cards)

                self.replay_cur_step  = #self.replay_cur_data.steps - 1
                self.replay_wait_time = 0
            end

            self.replay_cur_step  = self.replay_cur_step  + 2

            local step = (self.replay_cur_step  - 1) / 2
            self:slider_child(step,"Step",self.replay_node)
        end
    end
end

function Class:fast_step(step)
    local cards = {}
    for i,v in ipairs(game_ui.replay_cur_data.cards) do
        local id = self.replay_order[i]

        local data_new = {}

        for k,m in pairs( v.datas) do
            data_new[k] = m
        end

        cards[i] = {
            id = id,
            cur = data_new,
            hold = {},
            old = {},
            cheng = 0,
        }
    end

    local round_host_id = self:get_replay_round_host_id()
    self:re_enter(0,round_host_id,self.replay_order,
        cards,self.replay_cur_data.card_count,
        self.replay_cur_data.pi_card,{round=game_ui.replay_cur})

    self.not_anim = true

    self.replay_cur_step = 1
    local hu_game = false
    for i=1,step do
        local ind = self.replay_cur_data.steps[self.replay_cur_step+1]
        local cmd = math.floor(ind / 16)
        ind = ind % 16
        local card = self.replay_cur_data.steps[self.replay_cur_step]

        local id = self.replay_order[ind]

        --print(ind,cmd,id,card)

        if cmd == 0 then
            if card > 0  then
                self.cards[id].cur[0] = card
                self.card_count =  self.card_count - 1
            end
        elseif cmd == 1  then
            self:remove_card(id,card)
            local index = self.id_order[id]
            table.insert(self.cards[id].old,card)
            self.cur_player_id = id
        elseif cmd == 2  then
            self:remove_card(id,card,2)
            local hold_cards = self.cards[id].hold
            local len = #hold_cards
            table.insert(hold_cards,card)
            table.insert(hold_cards,card)
            table.insert(hold_cards,card)
            table.insert(hold_cards,0)

            self:del_cur_old()
        elseif cmd == 3  then
            local count  = 0
            for k,v in pairs(self.cards[id].cur) do
                if v == card then
                    count = count + 1
                end
            end
            self:room_gang(id,card,count)
        elseif cmd == 4  then
            local win_cards = {}
            for i,p_id in ipairs(self.order) do
                local cards = {}
                for i,v in ipairs(self.cards[p_id].cur) do
                    cards[i] = v
                end

                if self.cards[p_id].cur[0] then
                    table.insert(cards,1,self.cards[p_id].cur[0])
                end

                win_cards[i] = {datas=cards}
            end
            self:room_hu({id},win_cards)
            hu_game = true
            break
        end

        self.replay_cur_step  = self.replay_cur_step  + 2
    end

    self:draw_cards(hu_game)
    self:sub_card_count(0)

    self.not_anim = false

    self.replay_wait_time = 1
end

-- for 3d
function Class:delete_all_child(node)
    local n = 0
    local null_count = 0
    while true do
        local v  = node[n]
        if v then
            UnityEngine.GameObject.Destroy(v)
            null_count = 0
        else
            null_count = null_count + 1
            if null_count >= 3 then
                print(n)
                return
            end
        end
        n = n + 1
    end
end

function Class:hide_all_child(node)
    for _,v in pairs(node) do
        v:SetActive(false)
    end
end

function UserInfo(n)
    print("UserInfo")
    local id = game_ui.players[n].id
    proto.room:get_user_info(id)
end

return Class
